
## 1. 谈谈对volatile理解
A: 
volatile是JVM提供的轻量级的同步机制。
其涉及到JMM模型，JMM是一种抽象的Java内存模型规范。它屏蔽了各种硬件和操作系统的访问差异的，它保证了Java程序在各种平台下对内存的访问都能保证效果一致。
JMM的三大特性是：1.可见性，2.原子性，3有序性。
```bash
【可见性的扩展,hannpens-before规则】
happens-before是JMM最核心的概念。我们基于它提供的内存可见性来保障编程。
1，程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续的操作。
2，监视器锁的规则：锁的解锁happens-before随后对它的加锁。
3，volatile变量的规则：对一个volatile域的写happens-before于任意后续对它的读。
4，传递性：A happens-before B, B happens-before C，那么A happens-before C。
5，start()规则：线程A执行操作ThreadB.start()，那么A线程的ThreadB.start()操作happens-before 于B线程的任意操作。
这意味着：线程A在执行ThreadB.start()之前对共享变量所做的修改，在线程B执行后都将对B可见。
6，join()规则：线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before 于线程A从ThreadB.join()操作成功返回。

想想自己在阅读JUC下源码时是怎么理解那些正确同步的代码的
1. 我们看到synchronized会想到互斥，锁的释放还会引起共享变量的刷新，一个线程的对锁的释放与随后获取的线程实质上是在通信；
2. 看到volatile会想到它的读/写是原子的，且与锁的获取/释放具有相同的内存语义；
3. 看到循环CAS想到原子操作，且它具有volatile读/写的内存语义；

对于代码的执行顺序我们都默认是按顺序的，我们认为程序是按代码顺序来执行的;
可编译器与处理器是会重排序的，那是谁给了你这种保障，让你有这种按顺序执行的幻觉？
是JMM，你只要按照happens-before规则来编程，编写的程序是正确同步的，你就可以按顺序来理解它，编译器和处理器的重排序不会影响到你.
因为JMM对他们的限制，禁止了那些会改变执行结果的重排序。

JMM关于同步的规定：
1. 线程加锁前，必须读取主内存的最新值到自己的工作内存
2. 线程解锁前，必须把共享变量的值刷新回主内存
3. 加锁解锁是同一把锁
```
但是volatile只能保证：1.可见性；3.有序性(通过内存屏障来保障：写写、写读、读读、读写)
**不能保证：2.原子性**
比如对于一个被volatile修饰过的int变量，对这个变量进行n++操作的时候。编译器对这行代码进行编译的时候，会变成多个指令：1. getfield拿到原始值；2. iadd进行+1操作；3.putfield讲值写回。此时如果在A线程中进行这3个指令的操作，B线程是看不到的，而B线程也在同时操作当前这个共享变量的话，那么就会出现**写覆盖**的情况。

针对这种情况我可以利用JMM的原子性思想来解决
1. 比较重的方式是加上synchronized
2. 另外一种方式是使用JUC下面的AtomicInteger来解决


volatile可以应用于单例模型
单例模型通过双端检索机制(Double Check Lock)来保证单例的实现。
但是因为对象生成的时候会编译成也是三步的字节码指令，而在多线程环境下，如果没有volatile，会进行指令重排，指令重排算法虽然对数据有依赖的变量不进行重排，但它只保证单线程情况下执行结果的准确性，不会保证多线程之间的语义一致性。所以也会造成线程安全的问题。所以我对需要单例的对象上面加上volatile。

## CAS
如果线程的期望值跟物理内存的真实值一样，我就将其修改为我的更新值并返回True，否则不操作返回False。

比较典型的案例就是AtomicInterger

AtomicInterger底层是用volatile和cAS实现，其中CAS是一条CPU并发原语。
CAS并发原语在JAVA中的体现就是sun.misc.Unsafe类中的各个方法，调用这个类的话，JAVA会帮我们实现CAS汇编指令，它是完全依赖于硬件的功能。
因为原语是属于操作系统范畴，操作系统要求原语的执行必须是连续的，在执行过程中不允许被中断，所以CAS本身就是原子操作，不会出现数据不一致的问题。

CAS因为加上了自旋锁，所以循环时间比较长，开销也比较大。
读多写少的情况，那么就非常适合使用CAS，但是如果是IO密集型的业务。

**CAS与Synchronized进行比较**

-   synchronized    
    - 加锁，一致性保证，并发性下降 
    - 节省了资源，牺牲了并发
- CAS             
    - 不加锁，一致性保证，循环时间长开销大 
    - 消耗了资源，提高了并发

## ABA
CAS会导致ABA的问题，我们可以通过版本号的方法来规避这种情况出现。
AtomicReference可以把想要保证原子的数据类型封装起来
JAVA实现的话，有一个类叫AtomicStampedReference

## 线程不安全的ArrayList



